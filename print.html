<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cobalt Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Language</li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="builtin_types.html"><strong aria-hidden="true">3.</strong> Built-in types</a></li><li class="chapter-item expanded "><a href="custom_types.html"><strong aria-hidden="true">4.</strong> Custom types</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">5.</strong> Variables</a></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">6.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li class="chapter-item expanded "><a href="operators.html"><strong aria-hidden="true">8.</strong> Operators</a></li><li class="chapter-item expanded "><a href="literals.html"><strong aria-hidden="true">9.</strong> Literals</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">10.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Toolchain</li><li class="chapter-item expanded "><a href="co_cli.html"><strong aria-hidden="true">11.</strong> Compiler CLI</a></li><li class="chapter-item expanded affix "><li class="part-title">Contributors</li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">12.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="todo.html"><strong aria-hidden="true">13.</strong> TODO</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cobalt Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Cobalt is a high-level, compiled language with similar uses to C++. It aims to be more modern than C++, but offer more freedom than Rust.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="binaries"><a class="header" href="#binaries">Binaries</a></h3>
<p>Prebuilt versions are available from the <a href="https://github.com/matt-cornell/cobalt-lang/releases/latest">releases page</a>. As of right now, only the Linux <code>x86_64</code> build and Apple Silicon (<code>arm64</code>) is available.</p>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h3>
<p>In order to build from source, you will need <code>git</code>, <code>ssh</code>, and LLVM 15 (version 15.0.X for any minor version X). </p>
<p>The LLVM dependency is the most likely to cause trouble. It is unlikely that this specific version (e.g. 15.0.0) is already on your machine. You can download it by finding the appropriate version on the <a href="https://releases.llvm.org/download.html">LLVM releases page</a>, or through a package manager. Remember where you install it.</p>
<p>Now we are ready to build Cobalt. Visit the <a href="https://github.com/matt-cornell/cobalt-lang/">Github page</a> and clone the repository. Then, run <code>cargo build</code>:</p>
<pre><code>&gt; git clone https://github.com/matt-cornell/cobalt-lang
&gt; cd cobalt-lang
&gt; cargo build
</code></pre>
<p>By default, <code>cargo</code> builds the <code>dev</code> profile which is unoptimized and intended for testing/development. You can build release by adding the <code>--release</code> flag, e.g. <code>cargo build --release</code>.</p>
<p>Depending on how you installed LLVM, you may get compilation error mentioning missing <code>LLVM_SYS_150_PREFIX</code> and <code>LLVM_SYS_15_PREFIX</code> (or the <code>16</code> counterparts). Both of these environment variables should be set to point to where you installed LLVM. You can export these environment variables (so they are set globally) or export them directly to <code>cargo</code>. For example, if I installed LLVM in my home directory, I could do this:</p>
<pre><code>&gt; LLVM_SYS_150_PREFIX=~/llvm-15.0.0/ LLVM_SYS_15_PREFIX=~/llvm-15.0.0/ cargo build
</code></pre>
<h3 id="adding-to-path"><a class="header" href="#adding-to-path">Adding to path</a></h3>
<p>If you downloaded the prebuilt binary, you should now have an executable called <code>co</code>. If you build from source, it will probably be in <code>target/&lt;PROFILE&gt;/co</code>, where <code>&lt;PROFILE&gt;</code> is something like <code>debug</code> or <code>release</code>. In bash you can add this to <code>PATH</code> as follows:</p>
<pre><code>&gt; export PATH=path/to/co:$PATH
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>Let's write and compile the customary &quot;Hello, World!&quot; program in Cobalt.</p>
<h3 id="source-code"><a class="header" href="#source-code">Source code</a></h3>
<p>The standard file extesion for Cobalt source code is <code>.co</code>. We'll create and open a file called <code>hello_world.co</code>. In it, we write the following code: </p>
<pre><code>@C(extern) fn puts(str: *u8);

fn main(): i32 = {
    puts(&quot;Hello, World!&quot;);

    0
};
</code></pre>
<p>The first line declares that we want to use an externally-defined function <code>puts()</code>. </p>
<ul>
<li>The function <code>puts()</code> is defined in the C standard library, which Cobalt automatically links against.</li>
<li>The <code>@C(extern)</code> decoration can be thought of as declaring that the function <code>puts()</code> is defined in C. On a techincal level, it disables name mangling, sets calling convention, and marks <code>puts()</code> as externally defined.</li>
<li>We then tell Cobalt that the <code>puts()</code> function we are looking for takes a single argument (named <code>str</code>, though note that the actual name of the parameter is irrelevent) of type <code>*u8</code>.</li>
<li>The type <code>u8</code> represents a byte, and the type <code>*u8</code> represents a pointer to constant bytes. The C function <code>puts()</code> expects a single paramater of type <code>const char*</code>. A <code>char</code> in C is just a byte, so the C type <code>const char*</code> corresponds to the Cobalt type <code>*u8</code>.</li>
</ul>
<p>Next we define a function <code>main()</code> which takes no arguments and returns an <code>i32</code>, which is a 32-bit integer.</p>
<ul>
<li>The name <code>main</code> is not arbitrary; the compiler will look for the function with exactly this name to execute. Executing the program can be thought of as calling the function <code>main()</code>.</li>
<li>Note the <code>=</code> sign in the function declaration, and the <code>;</code> at the very end.</li>
<li>The function first calls <code>puts()</code> with the argument <code>&quot;Hello, World!&quot;</code>. String literals, surrounded by quotations marks, have type <code>*u8</code>. </li>
<li>Finally, the line <code>0</code> returns the value <code>0</code> from the function. There is no <code>return</code> keyword at the moment.</li>
</ul>
<h3 id="compiling"><a class="header" href="#compiling">Compiling</a></h3>
<p>The Cobalt compiler, which we'll just call <code>co</code> from now on, supports ahead-of-time (aot) and just-in-time (jit) compilation. On a basic level, aot compilation will output an executible file that can be run at any time. Jit compilation will run the program right now, and will not output any file. Let's see how to call both. If your shell cannot find a program named <code>co</code>, make sure it's in your path (see Installation above).</p>
<p>Jit looks like:</p>
<pre><code>&gt; co jit hello_world.co 
Hello, World!
</code></pre>
<p>Aot looks like:</p>
<pre><code>&gt; co aot hello_world.co 
&gt; ./hello_world
Hello, World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Cobalt uses <code>#</code> for comments. Multiline comments start with <code>#</code> and at least one <code>=</code>. They end with at least the same number of <code>=</code>s. This is done greedily on <code>=</code>s in the opening. Multiline comments do not currently nest. The following example, adapted from the &quot;Hello, World!&quot; example in the introduction, demonstrates this functionality:</p>
<pre><code>#=
 This is a multiline comment.
=#

#==
 This is another multiline comment.
==#

#===
 You can close a comment with the same or more `=`s than you 
 started with, but not less. So these won't close the comment:
 =#
 ==#
 But this will:
=======#

#==
 Comments can't be nested. There is no problem with writing 
 #========= yo! =#
 even though it is an invalid multiline comment, since the 
 parser does not treat it as a comment (since it is contained
 within a comment).
==#

#===#
 The parser is greedy on `=`s. So in the line above, the parser
 takes `#===` as the comment start, and `#` as the next character.

 It does not, for example see it as a comment start (`#=`)
 followed by a comment end (`==#`).
===#


@C(extern) fn puts(str: u8 const*);
fn main(): i32 = {
	#=
	 Multiline comments can also be put inside functions. 
	=#

	puts(&quot;Hello, World!&quot;c); # this prints to `stdout`

	#==
	 Here's another one. 
	==#

	0 # this is the return value

	#=
	 And another. 
	=#
};

#== This is the last one, I promise! ==#
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in types</a></h1>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>i{bits}</code></td><td>signed integer</td></tr>
<tr><td><code>isize</code></td><td>signed integer with same bits as a pointer</td></tr>
<tr><td><code>u{bits}</code></td><td>unsigned integer</td></tr>
<tr><td><code>usize</code></td><td>unsigned integer with same bits as a pointer</td></tr>
<tr><td><code>f{16|32|64|128}</code></td><td>floating-point number with specified bits</td></tr>
</tbody></table>
</div>
<p><code>bits</code> is any positive integer less that 65,536. Typically you want to stick to a power of <code>2</code>, and are probably good with using <code>32</code> or <code>64</code>.</p>
<h2 id="references-and-pointers"><a class="header" href="#references-and-pointers">References and pointers</a></h2>
<p>The primary difference between a reference and a pointer is that a pointer needs to be dereferenced in order to act like the underlying value, while a reference does not. For instance, suppose there is a type <code>T</code> with method <code>foo()</code>. Here's how you would call this method with a reference and with a pointer:</p>
<pre><code># Suppose `x_ref` has type `&amp;T`. 
x_ref.foo();

# Suppose `x_ptr` has type `*T`.
(*x_ptr).foo();
</code></pre>
<p>The underlying concept in play here is <em>decaying</em>. In this context, a reference <code>&amp;T</code> &quot;decays&quot; into <code>T</code>. You can think of this as an implicit conversion.</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>*T</code></td><td>pointer to type <code>T</code>: cannot change the memory being pointed to</td></tr>
<tr><td><code>*mut T</code></td><td>mutable pointer to type <code>T</code>: can change the memory being pointed to</td></tr>
<tr><td><code>&amp;T</code></td><td>reference to type <code>T</code>: cannot change the underlying instance</td></tr>
<tr><td><code>&amp;mut T</code></td><td>mutable reference to type <code>T</code>: can change the underlying instance</td></tr>
</tbody></table>
</div>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>description</th></tr></thead><tbody>
<tr><td><code>T[]</code></td><td>unsized array of objects of type <code>T</code></td></tr>
<tr><td><code>T[{size}]</code></td><td>sized array (with size <code>size</code>) of objects of type <code>T</code></td></tr>
</tbody></table>
</div>
<h3 id="unsized-arrays"><a class="header" href="#unsized-arrays">Unsized arrays</a></h3>
<p>There are two things to note:</p>
<ul>
<li><code>T[]</code> must be behind a reference.</li>
<li>The size is stored with the data as a fat pointer.</li>
</ul>
<p>Practically, this means you will not use variables of type <code>T[]</code> directly, but rather use references <code>&amp;T[]</code> or <code>&amp;mut T[]</code>. In this case, the reference can be thought of as a fat pointer which stores the size of the array. In particular, you don't need to keep track of the array size in a different variable.</p>
<h3 id="sized-arrays"><a class="header" href="#sized-arrays">Sized arrays</a></h3>
<p><code>size</code> must be computable at compile-time.</p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>syntax</th><th>description</th></tr></thead><tbody>
<tr><td><code>(T, U, V, ...)</code></td><td>tuple whose first element is type <code>T</code>, second is type <code>U</code>, etc.</td></tr>
</tbody></table>
</div>
<p>You can access the members with parentheses:</p>
<pre><code>let x: (i32, f32) = (3, 3.1415);
let x_int = x(0);
let x_float = x(1); 
</code></pre>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<h3 id="literals"><a class="header" href="#literals">Literals</a></h3>
<p>The simplest way to create a struct is to use literal notation.</p>
<pre><code>let monster = { alive: true, health: 97i32, };
</code></pre>
<p>In the above example, <code>monster</code> has type <code>{alive: bool, health: i32}</code>.</p>
<p>You can access fields using dot notation:</p>
<pre><code>let health = monster.health;
</code></pre>
<h3 id="nominals"><a class="header" href="#nominals">Nominals</a></h3>
<p>Structs can be named in the following way:</p>
<pre><code>type &lt;NAME&gt; = {
    &lt;FIELD_NAME&gt;: &lt;FIELD_TYPE&gt;,
    ...
}
</code></pre>
<p>To explicitly construct this, you need to use a bitcast:</p>
<p>Fields are accessed with dot notation. The following is an illustrative example:</p>
<pre><code>type MyStruct = {
	field1: bool,
	field2: i32,
};

fn main(): i32 = {
    # `x` has type `{ field1: bool, field2: i32, }`
	let x = { field1: false, field2: 3i32 };
    # `y` has type `MyStruct`
	let y = { field1: false, field2: 3i32 } :? MyStruct;
};
</code></pre>
<p>However, keep in mind that naming a type like this obfuscates the base type. What this means practically is that, to access the fields of a named struct, you must either cast it to it's base type beforehand or mark it with the <code>@transparent</code> annotation:</p>
<pre><code>@transparent
type MyStruct = {
	field1: bool,
	field2: i32,
};

fn main(): i32 = {
	let y = { field1: false, field2: 3i32 } :? MyStruct;

    y.field2
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h1>
<p>Types are defined using the <code>type</code> keyword. The simplest form is this:</p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt;;
</code></pre>
<p>where</p>
<ul>
<li><code>&lt;NAME&gt;</code> is the name of the type you want to define.</li>
<li><code>&lt;VAL&gt;</code> is the underlying representation.
This simple form is most useful for type-aliasing; i.e. providing a name for a preexisting type, potentially to hide the underlying properties of the preexisting type from users. For example,</li>
</ul>
<pre><code>type opaque_ptr = null const*;
</code></pre>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>If you define a type like </p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt;;
</code></pre>
<p>and you are able to construct the type <code>&lt;VAL&gt;</code>, then you can cast the type <code>&lt;VAL&gt;</code> into the type <code>&lt;NAME&gt;</code> using a bit cast, e.g.</p>
<pre><code>type MyInt = i32;

# Works
let x = 3i32;
let my_x = x :? MyInt;

# Also works
let my_y = 3i32 :? MyInt;

# Doesn't work-- you need to explicitly bit cast
let z = 3i32;
let my_z: MyInt = z;
</code></pre>
<p>You don't have to do this every time you construct your type. You can provide a <em>method</em> for construction. We'll discuss method more below.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>Every type has a default field <code>__base</code> (note there are two underscores) which accesses the base type.</p>
<pre><code>type MyInt = i32;

fn main(): i32 {
    let x1 = 3i32 :? MyInt;
    let x2 = 3i32 :? MyInt;

    # Two ways to access the base type.
    let y1 = x1 :? i32;
    let y2 = x2.__base;

    0
};
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods are defined in the following way: </p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt; :: {
    # Methods go here.
};
</code></pre>
<p>To define a method on an instance, use the <code>self_t</code> type: </p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt; :: {
    @method
    fn immut_method(s: &amp;self_t);

    @method
    fn mut_method(s: &amp;mut self_t);

    @method
    fn move_method(s: self_t);
};
</code></pre>
<p>You can refer to the type <code>&lt;VAL&gt;</code> as <code>base_t</code>:</p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt; :: {
    @getter 
    fn val(self: self_t): base_t = self :? base_t;
};
</code></pre>
<p>Methods are often decorated with the following annotations:</p>
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>@method</code></td><td>General purpose, allows method to be called.</td></tr>
<tr><td><code>@getter</code></td><td>Allows the method to be called like a field.</td></tr>
<tr><td><code>@op(drop)</code></td><td>Implement a destructor (see below).</td></tr>
</tbody></table>
</div>
<h3 id="method"><a class="header" href="#method"><code>@method</code></a></h3>
<p>Example:</p>
<pre><code>type 
</code></pre>
<h3 id="getter"><a class="header" href="#getter"><code>@getter</code></a></h3>
<pre><code>@C(extern)
fn puts(str: *u8);

type MyType = (i32, f32) :: {
	@getter
	@inline
	fn x(s: &amp;self_t): i32 = {
		s.__base(0)
	};
};

fn main(): i32 = {
	let my_type = (3i32, 9.9f32) :? MyType;
	if (my_type.x == 3i32) {  # Note we don't use `()` to call a getter.
		puts(&quot;Success&quot;);
	} else {
		puts(&quot;Failure&quot;);
	};

	0
};
</code></pre>
<h2 id="destructors"><a class="header" href="#destructors">Destructors</a></h2>
<p>A destructor is called when (after) an instance goes out of scope, and is responsible for cleaning up
memory and closing resources associated with the instance. For basic types and their derivatives, you 
do not need to worry about implementing this yourself.</p>
<p>Destructors are implemented as methods annotated with <code>@op(drop)</code> and accepting single <code>&amp;mut self_t</code> 
parameter. The return type is <code>null</code>.</p>
<pre><code>type &lt;NAME&gt; = &lt;VAL&gt; :: {
    @op(drop)
    fn my_custom_destructor(s: &amp;mut self) = {
        # Clean up here.
    };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables are defined with the <code>let</code> keyword. Types are deduced, but can also be manually specified:</p>
<pre><code>let x = 3i32;       # deduced type
let y: i32 = 4i32;  # explicit type
</code></pre>
<p>Mutable variables are marked by the <code>mut</code> keyword:</p>
<pre><code>let mut x = 3i32;
x = 5i32;
</code></pre>
<p>Variables which are known at compile time can be specified using the <code>const</code> keyword:</p>
<pre><code>const x = 5i32;
</code></pre>
<p>You do not include the <code>let</code> keyword.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-and-groupings"><a class="header" href="#blocks-and-groupings">Blocks and groupings</a></h1>
<p>Blocks (<code>{}</code>) and groupings (<code>()</code>) can sometimes be used interchangeably, but differ in subtle ways.</p>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p><em>Blocks</em> contain <em>statements</em> and evaluate to a value (of some type). They are delimited by braces (<code>{}</code>) . Blocks are themselves expressions. In particular, you may find that Cobalt requires semicolons after blocks where other languages do not.</p>
<pre><code># This is a block:
{
    let x = 1;

    # This is a block within a block:
    {
        let y = 2;    
    };

    let z = 3;
};  # semicolon!
</code></pre>
<p>Blocks are expressions with the same value as the last statement contained within them. In the above example, the last statement in the outermost block is <code>let z = 3;</code>. This is a non-expression statement. Recall that non-expression statements have value <code>null</code> and type <code>null</code>. On the other hand, if the last statement in the block is an expression, then the block is also an expression. In that case, the value of the block will be the value of the last expression contained within it (and the type of the value will be the type of the value of the last expression contained within it).</p>
<pre><code># `x` has type/value `null`
let x = {
    let y = 1;
};

# `z` has type `i32` and value `5` 
let z = {
    2i32 + 3i32 # uses i32 literal syntax 
};
</code></pre>
<p>An important property of blocks is that they introduce a new scope. This is similar to the scoping behavior in other languages.</p>
<pre><code>let x = 1;

let y = {
    let z = 2;

    # `x` is accessible in the inner scope
    z + x
};

# `z` is not accessible in the outer scope
</code></pre>
<h2 id="groupings"><a class="header" href="#groupings">Groupings</a></h2>
<p><em>Groupings</em> contain expressions, and are themselves expressions. Recall that every expression is a statement, but not every statement is an expression. In particular, groupings cannot contain non-expression statements. </p>
<p>Groupings are delimited by parenthesis (<code>()</code>). </p>
<p>The following is valid:</p>
<pre><code># `x` has type `i32` and value `2`
let x = (
    2i32
);

# `a` has type/value `null`
let a = (
    1 + 1;
);

# `y` has type `i32` and value `2`
let y = (
    (
        2i32
    )
);

# `b` has type/value `null`
let b = (
    # the value of an expression ending with a semicolon is `null`
    (
        2i32
    );
);
</code></pre>
<p>This, however, is not valid (compare with blocks):</p>
<pre><code># Compiler error!
let x = (
    let y = 1;
);
</code></pre>
<p>In some cases, though, groupings and blocks can be used interchangeably.</p>
<pre><code># `x` has type `i32` and value `2` 
let x = {
    2i32  
};

# `y` has type `i32` and value `2` 
let y = (
    2i32
);
</code></pre>
<p>If a grouping contains no expressions, then it is an expression which evalutes to null.</p>
<pre><code># `x` has type/value `null`
let x = ();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are defined as</p>
<pre><code>fn &lt;NAME&gt;(&lt;PARAM&gt;*): &lt;TYPE&gt; = &lt;EXPR&gt;
</code></pre>
<p>where</p>
<ul>
<li><code>&lt;NAME&gt;</code> is the name of the function.</li>
<li><code>&lt;PARAM&gt;</code> is a function parameter. These are described in more detail below. By <code>&lt;PARAM&gt;*</code> we mean that a function may have zero or more parameters. Each parameter must be separated by a comma.</li>
<li><code>&lt;TYPE&gt;</code> is the return type of the function. If none is specified, don't include the colon <code>:</code> and the return type will be assumed to be <code>null</code>.</li>
<li><code>&lt;EXPR&gt;</code> is an expression. Typically, this would be a block (<code>{..}</code>). If nothing is specified, this will default to <code>null</code>.</li>
</ul>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Each parameter has the form </p>
<pre><code>[const|mut] &lt;NAME&gt;: &lt;TYPE&gt; [= &lt;DEFAULT VAL&gt;]
</code></pre>
<p>where </p>
<ul>
<li><code>[const|mut]</code> means that, optionally, you can write <code>const</code> or <code>mut</code> before the type. <code>const</code> means the parameter is known at compile time. <code>mut</code> means the function can modify the parameter. If neither is specified, then you cannot change the value of the parameter.</li>
<li><code>&lt;NAME&gt;</code> is the name of the parameter, which can be used inside the function.</li>
<li><code>&lt;TYPE&gt;</code> is the type of the parameter.</li>
<li><code>[= &lt;DEFAULT VAL&gt;]</code> means that, optionally, you can provide a default value to the parameter. </li>
</ul>
<p>Note that having a reference parameter marked as <code>mut</code> is not the same as that parameter having type <code>&amp;mut Ty</code>. For instance, the paramaters <code>mut arg: &amp;i32</code> and <code>arg: &amp;mut i32</code> are not the same.</p>
<ul>
<li>In the first case, <code>mut arg: &amp;i32</code>, you can reassign what is being referenced by <code>arg</code> but cannot mutate the underlying object.</li>
<li>In the second case, <code>arg: &amp;mut i32</code>, you cannot reassign what is being referenced, but can mutate the underlying object.</li>
</ul>
<h3 id="reference-parameters"><a class="header" href="#reference-parameters">Reference parameters</a></h3>
<p>To call a function with a reference parameter, you can either provide a reference or a value. If you provide a value then it will be automatically converted into a reference. </p>
<pre><code>fn foo(x: &amp;i32);

fn bar(y: &amp;i32) = {
    # Pass a reference parameter directly.
    foo(y);
};

fn main(): i32 = {
    let x = 3i32;

    # Even though we pass in a value, since the function expects a reference it will convert it to a reference for us.
    foo(x);

    0
}
</code></pre>
<h2 id="annotations"><a class="header" href="#annotations">Annotations</a></h2>
<p>Annotations can be placed above function definitions. The following options are available:</p>
<div class="table-wrapper"><table><thead><tr><th>Annotation</th><th>Behavior</th></tr></thead><tbody>
<tr><td><code>@link(type)</code></td><td>set linkage</td></tr>
<tr><td><code>@linkas(name)</code></td><td>set link name</td></tr>
<tr><td><code>@cconv(convention)</code></td><td>set calling convention. can either be name or id</td></tr>
<tr><td><code>@extern(cconv (optional))</code></td><td>set function as externally defined</td></tr>
<tr><td><code>@inline(always | never)</code></td><td>inline function. may or may not actually be done</td></tr>
<tr><td><code>@C(extern (optional))</code></td><td>unmangle link name and use C calling convention</td></tr>
<tr><td><code>@target(glob)</code></td><td>only evaluate if the target matches the glob</td></tr>
<tr><td><code>@export(true | false (optional))</code></td><td>set module export, defaults to true</td></tr>
<tr><td><code>@private(true | false (optional))</code></td><td>does the opposite of <code>@export</code></td></tr>
<tr><td><code>@method</code> (types only)</td><td>mark a function as a method</td></tr>
<tr><td><code>@getter</code> (types only)</td><td>mark a function as a getter</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We can declare and use a function from <code>libc</code> as follows:</p>
<pre><code># Note both return type and body are inferred to be null.
@C(extern) fn puts(str: *u8); 

# Note the allowed paramaters to `main()`.
fn main(argc: i32, argv: **u8): i32 = {
  puts(&quot;Hello, World!&quot;);
  0
};
</code></pre>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<ul>
<li>If no body to a function is provided (and it is not <code>extern</code>) then the body defaults to null. In particular, the function can still be called.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<h2 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment operators</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>Ordinary assignment.</td></tr>
<tr><td><code>+=</code></td><td>Add and assign.</td></tr>
<tr><td><code>-=</code></td><td>Subtract and assign.</td></tr>
<tr><td><code>*=</code></td><td>Multiply and assign.</td></tr>
<tr><td><code>/=</code></td><td>Divide and assign.</td></tr>
<tr><td><code>%=</code></td><td>Mod and assign.</td></tr>
<tr><td><code>&amp;=</code></td><td>Bit and, and assign.</td></tr>
<tr><td><code>|=</code></td><td>Bit or, and assign.</td></tr>
<tr><td><code>^=</code></td><td>Bit XOR and assign.</td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>Bit shift left and assign.</td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>Bit shift right and assign.</td></tr>
</tbody></table>
</div>
<h2 id=""><a class="header" href="#"><code>:?</code></a></h2>
<p>The <code>:?</code> operator is a bit cast. It results in a move.</p>
<pre><code>type MyInt1 = i32;
type MyInt2 = MyInt1;

fn main() = {
    let x = 3i32 :? MyInt1;
    let y = x :? MyInt2;  # `x` moved here.

    # `x` is no longer valid.
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals-1"><a class="header" href="#literals-1">Literals</a></h1>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>String literals can be specified with double quotations:</p>
<pre><code>let s = &quot;Hello, world!&quot;;
</code></pre>
<p>A string literal can be immediately followed by <code>c</code>. This used to be required to pass string 
literals as parameters to (extern) functions expected C-style strings, <em>but is no longer 
necessary</em>. This is because string literals are automatically appended by a null terminator.
However, by default, this does not affect the length of the string. If you include the <code>c</code> 
suffix, it will:</p>
<pre><code># length is 2
let s1 = &quot;hi&quot;;

# length is 3
let s1 = &quot;hi&quot;c;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Modules are a way of giving a scope and namespace to your code. </p>
<h2 id="same-file"><a class="header" href="#same-file">Same-file</a></h2>
<p>The basic syntax is</p>
<pre><code>module &lt;NAME&gt; {
    &lt;TOP_LEVEL_DECLARATIONS&gt;+
};
</code></pre>
<p>Recall that a top level declarations can be functions and variable assignments. For example,</p>
<pre><code>module MyModule {
    let my_constant = 3i32;

    fn my_function(): i32 = {
        6i32
    };
};
</code></pre>
<h2 id="using-it"><a class="header" href="#using-it">Using it</a></h2>
<p>To use the things defined in a module, you have a few options. </p>
<p>If the module is defined in the same file you want to use it, then you can prefix its elements with 
the module name, kind of like a namespace:</p>
<pre><code>module MyModule {
    let my_constant = 3i32;
};

fn foo(): i32 = {
    MyModule.my_constant
};

</code></pre>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>If/when that gets tedious, you can bring the module's contents into the current scope by importing it:</p>
<pre><code>module MyModule {
    let my_constant = 3i32;
    let my_other_constant = 5i32;
};

import MyModule.*;

fn foo(): i32 = {
    MyModule.my_constant
};
</code></pre>
<p>The wildcard <code>*</code> imports all elements of the module. You can import a single item like this:</p>
<pre><code>import MyModule.my_constant;
</code></pre>
<p>or multiple items like this:</p>
<pre><code>import MyModule.{my_constant, my_other_constant};
</code></pre>
<h2 id="managing-scopes"><a class="header" href="#managing-scopes">Managing scopes</a></h2>
<p>When a project starts to grow it is often useful to break things up. TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-cli"><a class="header" href="#compiler-cli">Compiler CLI</a></h1>
<p>This page details the various commands and options you can specify in the compiler. 
If you are just looking for how to get started compiling some code, this might not 
be the best place to look (at first). </p>
<h2 id="top-level"><a class="header" href="#top-level">Top level</a></h2>
<p>These are options and commands that can be specified immediately after invoking <code>co</code>, e.g.</p>
<pre><code>&gt; co &lt;OPTION&gt;
</code></pre>
<p>The following return immediately:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-h</code>, <code>--help</code></td><td>Print help.</td></tr>
<tr><td><code>-V</code>, <code>--version</code>, <code>version</code></td><td>Print version.</td></tr>
</tbody></table>
</div>
<p>The following are commands, and entry points to more options:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td>Print version information.</td></tr>
<tr><td><code>debug</code></td><td>Debug compiler stuff.</td></tr>
<tr><td><code>aot</code></td><td>AOT compile a file.</td></tr>
<tr><td><code>jit</code></td><td>JIT compile and run a file.</td></tr>
<tr><td><code>check</code></td><td>Check a file for errors.</td></tr>
<tr><td><code>multi</code></td><td>Multi-file utilities.</td></tr>
<tr><td><code>project</code></td><td>Project-related utilities.</td></tr>
<tr><td><code>package</code></td><td>Package-related utilities (not currently supported).</td></tr>
<tr><td><code>help</code></td><td>Print help or the help of the given subcommand(s).</td></tr>
</tbody></table>
</div>
<p>In particular, you can query the compiler to provide help on any of these commands
by using the <code>help</code> command, e.g. </p>
<pre><code>&gt; co help aot
</code></pre>
<h2 id="aot"><a class="header" href="#aot">aot</a></h2>
<p>The model is </p>
<pre><code>&gt; co aot [OPTION] &lt;INPUT&gt;
</code></pre>
<p><code>&lt;INPUT&gt;</code> is the primary file to compile. The following (optional) options are supported:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>[-o | --output] &lt;OUTPUT&gt;</code></td><td>Specify an output file name.</td></tr>
<tr><td><code>-l &lt;LINKED&gt;</code></td><td>Specify libraries to link.</td></tr>
<tr><td><code>-L &lt;LINK_DIRS&gt;</code></td><td>Specify directories to look for libraries in.</td></tr>
<tr><td><code>-H &lt;HEADERS&gt;</code></td><td>Specify Cobalt headers to include.</td></tr>
<tr><td><code>-t, --triple &lt;TRIPLE&gt;</code></td><td>Specify the target triple to build for.</td></tr>
<tr><td><code>[-e | --emit] &lt;EMIT&gt;</code></td><td>Specify the type of file to emit.</td></tr>
<tr><td><code>[-p | --profile] &lt;PROFILE&gt;</code></td><td>Specify which optimization profile to use.</td></tr>
<tr><td><code>[-d | --debug]</code></td><td>Emit symbols with debug mangling.</td></tr>
<tr><td><code>--no-default-link</code></td><td>Don't search default directories for libraries.</td></tr>
<tr><td><code>--timings</code></td><td>Print timings.</td></tr>
<tr><td><code>-h, --help</code></td><td>Print help</td></tr>
</tbody></table>
</div>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>For <code>-o</code>:</p>
<ul>
<li>If no output file name is specified, one is chosen based on the input filename.</li>
</ul>
<p>For <code>-l</code>:</p>
<ul>
<li>The compiler automatically looks in the working directory.</li>
<li>Specifying libraries is similar to <code>gcc</code> in that you need not specify the <code>lib</code>
prefix to the library file, if there is one. A file called <code>libadd.dylib</code> can be specified 
as <code>-l add</code>.</li>
</ul>
<p>For <code>-e</code>:</p>
<ul>
<li>The possible options are </li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>exe</code></td><td>executable <em>(default)</em></td></tr>
<tr><td><code>lib</code></td><td>dynamic library</td></tr>
<tr><td><code>obj</code></td><td>object file</td></tr>
<tr><td><code>raw-obj</code></td><td>object file, minus Cobalt headers</td></tr>
<tr><td><code>asm</code></td><td>assembly</td></tr>
<tr><td><code>llvm</code></td><td>LLVM IR</td></tr>
<tr><td><code>bc</code></td><td>LLVM bitcode</td></tr>
<tr><td><code>header</code></td><td>Cobalt library header</td></tr>
</tbody></table>
</div>
<p>For <code>-p</code>:</p>
<ul>
<li>The following optimization profiles are built-in:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Profile</th></tr></thead><tbody>
<tr><td><code>none | 0</code></td></tr>
<tr><td><code>less | 1</code></td></tr>
<tr><td><code>default | 2</code></td></tr>
<tr><td><code>aggressive | 3</code></td></tr>
</tbody></table>
</div>
<ul>
<li>Profiles can also be specified in files.</li>
<li>The syntax of the profile file is as follows: each line has a pass, with an optional 
additional argument (only two passes take these). Empty lines are ignored, and anything 
after a <code>#</code> is a comment. Here is an example:</li>
</ul>
<pre><code>psccp
IPSCCP # This is the same as the previous one
scalar-repl-aggregates = 5 # both the pass and the value are trimmed
internalize = true
</code></pre>
<ul>
<li>If you specify a name of a file, the following locations are searched, in this order:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Location</th></tr></thead><tbody>
<tr><td><code>$COBALT_DIR/profiles/</code></td></tr>
<tr><td><code>$HOME/.cobalt/profiles/</code></td></tr>
<tr><td><code>$HOME/.config/cobalt/profiles/</code></td></tr>
<tr><td><code>/usr/local/share/cobalt/profiles/</code></td></tr>
<tr><td><code>/usr/share/cobalt/profiles/</code></td></tr>
</tbody></table>
</div>
<h2 id="jit"><a class="header" href="#jit">jit</a></h2>
<p>Just-in-time compilation can be achieved via </p>
<pre><code>&gt; co jit &lt;FILE&gt;
</code></pre>
<p>with most of the options above being valid here too.</p>
<h2 id="check"><a class="header" href="#check">check</a></h2>
<p><code>co check</code> goes through the frontend stages of compilation, but does not emit a compiled
output. It takes most of the same commands as <code>co jit</code>. </p>
<h2 id="debug-only-subcommands"><a class="header" href="#debug-only-subcommands">Debug-only subcommands</a></h2>
<p>The following commands are only available on debug builds of the compiler. They begin as </p>
<pre><code>&gt; co dbg &lt;SUBCOMMAND&gt;
</code></pre>
<p>The following subcommands are available:</p>
<div class="table-wrapper"><table><thead><tr><th>Subcommand</th><th>Description</th></tr></thead><tbody>
<tr><td><code>parse</code></td><td>Print generated AST.</td></tr>
<tr><td><code>llvm</code></td><td>Print unoptimized llvm output.</td></tr>
<tr><td><code>parse-header</code></td><td>Loads header files and prints the symbols.</td></tr>
</tbody></table>
</div>
<h3 id="notes-and-examples"><a class="header" href="#notes-and-examples">Notes and examples</a></h3>
<p>For <code>parse</code>:</p>
<ul>
<li>Directly input code via the <code>-c</code> flag, e.g.</li>
</ul>
<pre><code>&gt; co dbg parse -c 'let x = 10;'
</code></pre>
<ul>
<li>Show the locations of the AST nodes in the source file with the <code>-l</code> flag, e.g.</li>
</ul>
<pre><code>&gt; co dbg parse -l test.co
</code></pre>
<ul>
<li>You can supply multiple input files, e.g. </li>
</ul>
<pre><code>&gt; co dbg parse test1.co test2.co
</code></pre>
<p>For <code>parse-header</code>:</p>
<ul>
<li>Sample usage:</li>
</ul>
<pre><code>&gt; co aot --header test.coh
&gt; co dbg parse-header test.coh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The parser constructs the AST, and the AST builds a partial CFG (in BlockAST and FnDefAST to be specific) 
after it evaluates the body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-lists"><a class="header" href="#todo-lists">TODO Lists</a></h1>
<p>These lists help both the developers keep track of what we've planned, and show the users what's coming.
Once everything here has been completed, this file may be deleted.</p>
<h2 id="unimplemented-features"><a class="header" href="#unimplemented-features">Unimplemented Features</a></h2>
<p>This is a list of planned features that are currently unimplemented.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Constant function evaluation</li>
<li><input disabled="" type="checkbox"/>
Generics</li>
<li><input disabled="" type="checkbox"/>
Traits</li>
</ul>
<h2 id="undocumented-features"><a class="header" href="#undocumented-features">Undocumented Features</a></h2>
<p>Things here are perfectly usable, but you won't find them anywhere in the documentation.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Syntax
<ul>
<li><input disabled="" type="checkbox"/>
Literals
<ul>
<li><input disabled="" type="checkbox"/>
Numeric
<ul>
<li><input disabled="" type="checkbox"/>
Integer</li>
<li><input disabled="" type="checkbox"/>
Floats</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
String</li>
<li><input disabled="" type="checkbox"/>
Character</li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Semantics
<ul>
<li><input disabled="" type="checkbox"/>
Modules -- incomplete</li>
</ul>
</li>
</ul>
<h2 id="incorrect-or-out-of-date-documentation"><a class="header" href="#incorrect-or-out-of-date-documentation">Incorrect or Out of Date Documentation</a></h2>
<p>These are places where the documentation is just wrong.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Installation
<ul>
<li><input disabled="" type="checkbox"/>
Use LLVM 16 instead of LLVM 15</li>
<li><input disabled="" type="checkbox"/>
Use <code>cargo install --git</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Functions -- don't mention <code>mut arg: &amp;T</code>. Nothing good will come of this (you'll probably break something)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
